<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>H·ªá Th·ªëng L∆∞·ªõi ƒêi·ªán v14.0 (Ch·∫©n ƒêo√°n L·ªói)</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    
    <style>
        body { margin: 0; padding: 0; font-family: 'Segoe UI', sans-serif; display: flex; height: 100vh; background: #f4f6f8; }
        
        #sidebar {
            width: 450px; background: white; border-right: 1px solid #ccc;
            display: flex; flex-direction: column; z-index: 2000; box-shadow: 2px 0 10px rgba(0,0,0,0.1);
        }
        
        .header { background: #2c3e50; color: white; padding: 15px; }
        .header h2 { margin: 0; font-size: 1.1rem; }
        
        .content { padding: 15px; overflow-y: auto; flex: 1; }
        
        /* Debug Console Style */
        #debug-console {
            background: #212121; color: #00e676; font-family: 'Consolas', monospace;
            padding: 10px; border-radius: 4px; font-size: 0.8rem;
            max-height: 200px; overflow-y: auto; margin-bottom: 15px;
            white-space: pre-wrap; border: 1px solid #444;
        }
        .log-err { color: #ff5252; font-weight: bold; }
        .log-warn { color: #ffab40; }
        .log-info { color: #40c4ff; }

        .card { background: white; padding: 15px; border: 1px solid #ddd; border-radius: 6px; margin-bottom: 15px; }
        label { font-weight: 600; font-size: 0.9rem; display: block; margin-bottom: 5px; }
        
        button { padding: 10px; width: 100%; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; margin-bottom: 5px; }
        .btn-check { background: #607d8b; color: white; }
        .btn-upload { background: #e65100; color: white; }
        .btn-view { background: #0277bd; color: white; }
        button:disabled { background: #ccc; cursor: not-allowed; }

        #segment-list { font-size: 0.8rem; border: 1px solid #eee; height: 150px; overflow-y: auto; }
        .seg-row { padding: 5px; border-bottom: 1px dashed #eee; display: flex; justify-content: space-between; }
    </style>
</head>
<body>

    <div id="sidebar">
        <div class="header">
            <h2><i class="fas fa-tools"></i> Admin & Debugger</h2>
        </div>

        <div class="content">
            <div class="card">
                <label>1. Ki·ªÉm tra & Upload D·ªØ li·ªáu:</label>
                <input type="file" id="excelFile" accept=".xlsx" style="margin-bottom:10px; width:100%"/>
                
                <button class="btn-check" onclick="analyzeFile()">
                    <i class="fas fa-stethoscope"></i> Ph√¢n T√≠ch T√¨m L·ªói
                </button>
                
                <div id="debug-console">Tr·∫°ng th√°i: Ch·ªù file...</div>

                <button class="btn-upload" id="btnUpload" onclick="uploadToCloud()" disabled>
                    <i class="fas fa-cloud-upload-alt"></i> D·ªØ li·ªáu OK -> Upload ngay
                </button>
            </div>

            <div style="font-size:0.8rem; color:green; margin-bottom:10px;" id="cloud-status">
                <i class="fas fa-wifi"></i> ƒêang k·∫øt n·ªëi Firebase...
            </div>

            <div class="card">
                <label>2. Xem B·∫£n ƒê·ªì:</label>
                <button class="btn-view" onclick="drawAll()">
                    <i class="fas fa-map"></i> V·∫Ω T·∫•t C·∫£ M·∫°ch
                </button>
                
                <label style="margin-top:10px">Ho·∫∑c xem t·ª´ng m·∫°ch:</label>
                <select id="circuitSelect" onchange="drawSingle()">
                    <option value="">-- Ch·ªçn m·∫°ch --</option>
                </select>
                <div id="segment-list"></div>
            </div>
        </div>
    </div>

    <div id="map" style="flex:1;"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-polylineoffset@1.1.1/leaflet.polylineoffset.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getDatabase, ref, set, onValue } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";

        const firebaseConfig = {
            apiKey: "AIzaSyCzWjfcD5Dgq7V-i2izb9tKLR6QM6qWPQo",
            authDomain: "tavietnam-78ae8.firebaseapp.com",
            projectId: "tavietnam-78ae8",
            storageBucket: "tavietnam-78ae8.firebasestorage.app",
            messagingSenderId: "670121705534",
            appId: "1:670121705534:web:1027ad98550573ad37116f"
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        window.db = db; window.set = set; window.ref = ref; window.onValue = onValue;

        listenCloud();
    </script>

    <script>
        let map;
        let layers = { bg: L.layerGroup(), main: L.layerGroup() };
        let appData = { poles: {}, segments: {}, circuits: {} };
        let stagingData = null; // D·ªØ li·ªáu ch·ªù upload

        function initMap() {
            map = L.map('map').setView([10.762622, 106.660172], 12);
            L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {attribution: 'Esri'}).addTo(map);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {opacity: 0.4}).addTo(map);
            Object.values(layers).forEach(l => l.addTo(map));
        }
        initMap();

        function log(msg, type='info') {
            const c = document.getElementById('debug-console');
            let color = type=='err'?'#ff5252':(type=='warn'?'#ffab40':'#00e676');
            c.innerHTML += `<div style="color:${color}">> ${msg}</div>`;
            c.scrollTop = c.scrollHeight;
        }

        // --- 1. PH√ÇN T√çCH FILE (QUAN TR·ªåNG) ---
        function analyzeFile() {
            const input = document.getElementById('excelFile');
            const consoleBox = document.getElementById('debug-console');
            consoleBox.innerHTML = ""; // Clear log
            document.getElementById('btnUpload').disabled = true;

            if(!input.files.length) return log("Ch∆∞a ch·ªçn file!", 'err');

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    log("ƒêang ƒë·ªçc file Excel...");
                    const wb = XLSX.read(e.target.result, {type:'array'});
                    
                    // T√¨m Sheets
                    const findS = (k) => wb.SheetNames.find(n => k.some(x => n.toUpperCase().includes(x)));
                    const sPoles = findS(["TOA_DO","TRU"]);
                    const sSegs = findS(["DOAN","SEG"]);
                    const sCircs = findS(["CAU_HINH","MACH","DUONG"]);

                    if(!sPoles) log("‚ùå Thi·∫øu Sheet T·ªça ƒë·ªô Tr·ª• (c·∫ßn t√™n ch·ª©a 'TRU', 'TOA_DO')", 'err');
                    if(!sSegs) log("‚ùå Thi·∫øu Sheet Danh m·ª•c ƒêo·∫°n (c·∫ßn t√™n ch·ª©a 'DOAN', 'SEG')", 'err');
                    if(!sCircs) log("‚ùå Thi·∫øu Sheet C·∫•u h√¨nh M·∫°ch (c·∫ßn t√™n ch·ª©a 'MACH', 'CAU_HINH')", 'err');

                    if(!sPoles || !sSegs || !sCircs) return;

                    const rawPoles = XLSX.utils.sheet_to_json(wb.Sheets[sPoles]);
                    const rawSegs = XLSX.utils.sheet_to_json(wb.Sheets[sSegs]);
                    const rawCircs = XLSX.utils.sheet_to_json(wb.Sheets[sCircs]);

                    log(`‚úÖ ƒê√£ ƒë·ªçc: ${rawPoles.length} d√≤ng Tr·ª•, ${rawSegs.length} d√≤ng ƒêo·∫°n, ${rawCircs.length} d√≤ng M·∫°ch.`);

                    // --- KI·ªÇM TRA LOGIC ---
                    let cleanData = { poles: {}, segments: {}, circuits: {} };
                    let errors = 0;

                    // 1. Check TR·ª§
                    rawPoles.forEach((r, i) => {
                        let row = norm(r);
                        let line = row.MA_TUYEN || row.TUYEN;
                        let name = row.TEN_TRU || row.VI_TRI;
                        if(line && name) {
                            if(!cleanData.poles[line]) cleanData.poles[line] = [];
                            let sort = parseInt((name.toString().match(/\d+/) || [9999])[0]);
                            cleanData.poles[line].push({name: name.toString(), lat: row.LAT, lng: row.LONG, sort});
                        } else {
                            // log(`‚ö†Ô∏è Sheet Tr·ª• d√≤ng ${i+2}: Thi·∫øu M√£ Tuy·∫øn ho·∫∑c T√™n Tr·ª•`, 'warn');
                        }
                    });
                    
                    // Sort Tr·ª•
                    for(let k in cleanData.poles) cleanData.poles[k].sort((a,b)=>a.sort-b.sort);

                    // 2. Check ƒêO·∫†N
                    rawSegs.forEach((r, i) => {
                        let row = norm(r);
                        let id = row.MA_DOAN;
                        let line = row.MA_TUYEN || row.TUYEN;
                        
                        if(!id) return log(`‚ùå Sheet ƒêo·∫°n d√≤ng ${i+2}: Thi·∫øu M√£ ƒêo·∫°n`, 'err');
                        if(!line) return log(`‚ùå Sheet ƒêo·∫°n d√≤ng ${i+2} (${id}): Thi·∫øu M√£ Tuy·∫øn`, 'err');
                        
                        // Check link t·ªõi Tr·ª•
                        if(!cleanData.poles[line]) {
                            log(`‚ö†Ô∏è Sheet ƒêo·∫°n d√≤ng ${i+2} (${id}): Tuy·∫øn '${line}' kh√¥ng c√≥ trong Sheet Tr·ª•!`, 'warn');
                            errors++;
                        }
                        
                        cleanData.segments[id] = { id, line, from: row.TU_TRU, to: row.DEN_TRU };
                    });

                    // 3. Check M·∫†CH (QUAN TR·ªåNG NH·∫§T)
                    rawCircs.forEach((r, i) => {
                        let row = norm(r);
                        let cid = row.MA_DUONG_DAY || row.MA_MACH;
                        let sid = row.MA_DOAN;
                        
                        if(!cid) return; // B·ªè qua d√≤ng tr·ªëng
                        
                        if(!sid) {
                            log(`‚ùå Sheet M·∫°ch d√≤ng ${i+2}: M·∫°ch '${cid}' thi·∫øu M√£ ƒêo·∫°n`, 'err');
                            errors++;
                            return;
                        }

                        // Check link t·ªõi ƒêo·∫°n
                        if(!cleanData.segments[sid]) {
                            log(`‚ùå Sheet M·∫°ch d√≤ng ${i+2}: M·∫°ch '${cid}' g·ªçi ƒëo·∫°n '${sid}' nh∆∞ng ƒëo·∫°n n√†y KH√îNG C√ì trong Sheet ƒêo·∫°n!`, 'err');
                            errors++;
                        } else {
                            if(!cleanData.circuits[cid]) cleanData.circuits[cid] = [];
                            cleanData.circuits[cid].push({ segId: sid, order: parseInt(row.STT||999) });
                        }
                    });

                    // T·ªïng k·∫øt
                    if(errors > 0) {
                        log(`üö´ T√åM TH·∫§Y ${errors} L·ªñI D·ªÆ LI·ªÜU. VUI L√íNG S·ª¨A EXCEL TR∆Ø·ªöC KHI UPLOAD.`, 'err');
                    } else {
                        log(`‚ú® D·ªØ li·ªáu s·∫°ch s·∫Ω! S·∫µn s√†ng upload.`, 'info');
                        // Sort circuits
                        for(let k in cleanData.circuits) cleanData.circuits[k].sort((a,b)=>a.order-b.order);
                        stagingData = cleanData;
                        document.getElementById('btnUpload').disabled = false;
                    }

                } catch(err) {
                    log("Crashed: " + err.message, 'err');
                }
            };
            reader.readAsArrayBuffer(input.files[0]);
        }

        // --- UPLOAD ---
        function uploadToCloud() {
            if(!stagingData) return;
            log("ƒêang ƒë·∫©y l√™n Firebase...");
            window.set(window.ref(window.db, 'he_thong_luoi_dien'), stagingData)
                .then(() => log("‚úÖ Upload th√†nh c√¥ng!", 'info'))
                .catch(e => log("L·ªói Upload: "+e.message, 'err'));
        }

        function norm(obj) {
            let n = {}; Object.keys(obj).forEach(k => n[k.trim().toUpperCase().replace(/ /g,"_")] = obj[k]); return n;
        }

        // --- VIEW MODE ---
        function listenCloud() {
            window.onValue(window.ref(window.db, 'he_thong_luoi_dien'), (snap) => {
                const val = snap.val();
                if(val) {
                    appData = val;
                    document.getElementById('cloud-status').innerHTML = "üü¢ ƒê√£ k·∫øt n·ªëi Cloud";
                    updateUI();
                }
            });
        }

        function updateUI() {
            const s = document.getElementById('circuitSelect');
            s.innerHTML = '<option value="">-- Ch·ªçn m·∫°ch --</option>';
            if(appData.circuits) Object.keys(appData.circuits).forEach(k => {
                let o = document.createElement('option'); o.value=k; o.text=k; s.add(o);
            });
        }

        function drawAll() {
            layers.main.clearLayers();
            if(!appData.circuits) return;
            let keys = Object.keys(appData.circuits);
            keys.forEach((cid, idx) => {
                let pts = getPoints(cid);
                if(pts.length) {
                    // Offset ƒë·ªÉ t√°ch d√≤ng
                    let offset = (idx - keys.length/2) * 5;
                    L.polyline(pts.map(p=>[p.lat,p.lng]), {color:'blue', weight:2, offset: offset}).addTo(layers.main).bindPopup(cid);
                }
            });
            if(keys.length) {
                let pts = getPoints(keys[0]);
                if(pts.length) map.fitBounds(pts.map(p=>[p.lat,p.lng]));
            }
        }

        function drawSingle() {
            layers.main.clearLayers();
            const cid = document.getElementById('circuitSelect').value;
            const pts = getPoints(cid);
            if(pts.length) {
                L.polyline(pts.map(p=>[p.lat,p.lng]), {color:'red', weight:4}).addTo(layers.main);
                map.fitBounds(pts.map(p=>[p.lat,p.lng]));
            }
        }

        function getPoints(cid) {
            let pts = [];
            const segs = appData.circuits[cid];
            if(!segs) return [];
            segs.forEach(item => {
                const def = appData.segments[item.segId];
                if(def && appData.poles[def.line]) {
                    const lData = appData.poles[def.line];
                    let i1 = lData.findIndex(p=>p.name==def.from);
                    let i2 = lData.findIndex(p=>p.name==def.to);
                    if(i1>=0 && i2>=0) {
                        let sub = (i1<=i2) ? lData.slice(i1,i2+1) : lData.slice(i2,i1+1).reverse();
                        pts = pts.concat(sub);
                    }
                }
            });
            return pts;
        }

    </script>
</body>
</html>

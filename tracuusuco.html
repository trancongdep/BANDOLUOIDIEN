
<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>V·∫≠n H√†nh L∆∞·ªõi ƒêi·ªán - Mobile v1.2</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    
    <style>
        /* --- MOBILE FIRST CSS --- */
        html, body { margin: 0; padding: 0; width: 100%; height: 100%; font-family: 'Segoe UI', sans-serif; overflow: hidden; background: #f0f2f5; }
        #map { position: absolute; top: 0; left: 0; right: 0; bottom: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* HEADER & MENU BUTTON */
        .app-bar {
            position: absolute; top: 10px; left: 10px; right: 10px; height: 50px;
            background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 2000; display: flex; align-items: center; padding: 0 10px;
            justify-content: space-between;
        }
        .app-title { font-weight: bold; color: #004d40; font-size: 1rem; }
        .btn-menu { border: none; background: none; font-size: 1.2rem; color: #333; padding: 10px; cursor: pointer; }

        /* CONTROLS PANEL */
        #control-panel {
            position: fixed; bottom: -100%; left: 0; width: 100%; 
            background: white; z-index: 3000; border-top-left-radius: 15px; border-top-right-radius: 15px;
            box-shadow: 0 -2px 20px rgba(0,0,0,0.3); transition: bottom 0.3s ease-in-out;
            max-height: 80%; overflow-y: auto; padding-bottom: 20px;
        }
        #control-panel.active { bottom: 0; }
        
        .panel-header {
            padding: 15px; background: #004d40; color: white; border-top-left-radius: 15px; border-top-right-radius: 15px;
            display: flex; justify-content: space-between; align-items: center; font-weight: bold;
        }
        .panel-body { padding: 15px; }

        /* FORM ELEMENTS */
        label { font-weight: 600; font-size: 0.9rem; display: block; margin: 10px 0 5px; color: #555; }
        select, input { width: 100%; padding: 12px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 6px; box-sizing: border-box; font-size: 1rem; }
        
        button.action-btn { 
            padding: 12px; width: 100%; border: none; border-radius: 6px; cursor: pointer; 
            font-weight: bold; margin-bottom: 10px; transition: 0.2s; color: white; font-size: 1rem; 
            display: flex; justify-content: center; align-items: center; gap: 8px;
        }
        .btn-find { background: #d32f2f; }
        .btn-ground { background: #0288d1; }
        .btn-gps { position: absolute; bottom: 100px; right: 10px; z-index: 2000; background: white; width: 40px; height: 40px; border-radius: 50%; box-shadow: 0 2px 5px rgba(0,0,0,0.3); border: none; font-size: 1.2rem; color: #0078d7; display: flex; align-items: center; justify-content: center; cursor: pointer; }

        /* RADIO GROUP */
        .radio-group { display: flex; flex-direction: row; align-items: center; gap: 30px; margin-bottom: 15px; width: 100%; }
        .radio-group label { margin: 0; font-weight: normal; cursor: pointer; display: flex; align-items: center; font-size: 1rem; }
        .radio-group input { width: 20px; height: 20px; margin-right: 8px; }

        /* DIALOG */
        #custom-confirm { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 9999; justify-content: center; align-items: center; backdrop-filter: blur(2px); }
        .win-dialog { background: #fff; width: 90%; max-width: 350px; border-radius: 8px; overflow: hidden; box-shadow: 0 4px 20px rgba(0,0,0,0.4); animation: popIn 0.2s ease-out; }
        @keyframes popIn { from { transform: scale(0.9); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .win-body { padding: 20px; text-align: center; }
        .win-footer { padding: 10px; background: #f5f5f5; display: flex; gap: 10px; }
        .win-btn { flex: 1; padding: 10px; border: none; border-radius: 4px; font-weight: bold; cursor: pointer; }
        .btn-yes { background: #0078d7; color: white; }
        .btn-no { background: #ddd; color: #333; }

        /* FAULT & WEATHER */
        .fault-box { display: none; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 0 20px rgba(255, 0, 0, 0.4); border-left: 5px solid #d32f2f; width: 85%; max-width: 300px; position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 4000; font-size: 0.9rem; }
        .fault-header { color: #d32f2f; font-weight: bold; display: flex; justify-content: space-between; margin-bottom: 5px; }
        .weather-info { background: #e3f2fd; padding: 8px; border-radius: 4px; margin-top: 5px; font-size: 0.85rem; border: 1px solid #90caf9; }
        .weather-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
        .weather-alert { color: #d32f2f; font-weight: bold; margin-top: 4px; border-top: 1px dashed #999; padding-top: 4px; }
        
        /* ICONS & MARKERS */
        .my-icon { border: 1px solid white; box-shadow: 1px 1px 3px rgba(0,0,0,0.6); text-align: center; font-size: 9px; display: flex; justify-content: center; align-items: center; color: white; font-weight: bold; }
        .icon-tru-do { background: #1976d2; border-radius: 50%; border: 2px solid white; }
        .icon-tru-neo { background: #1976d2; border-radius: 2px; border: 2px solid white; }
        .icon-mc-base { border: 2px solid white; border-radius: 2px; z-index: 1000; }
        .icon-mc-source { border: 2px solid #ffeb3b !important; box-shadow: 0 0 5px #ffeb3b; z-index: 1001 !important; }
        .fault-marker { font-size: 40px; color: #d32f2f; text-shadow: 0 0 10px #ffeb3b; animation: flash 0.5s infinite alternate; }
        @keyframes flash { from { opacity: 1; transform: scale(1); } to { opacity: 0.5; transform: scale(1.2); } }
        
        .warning-msg { color: #d32f2f; background: #ffebee; padding: 10px; border-radius: 4px; border: 1px solid #ffcdd2; margin-top: 10px; display: none; font-weight: bold; text-align: center; }
        .legend { background: rgba(255,255,255,0.9); padding: 5px 8px; border-radius: 4px; font-size: 0.7rem; display: block; margin-bottom: 50px !important; }
        .legend-item { display: flex; align-items: center; margin-bottom: 2px; }
        .legend-icon { width: 12px; height: 12px; margin-right: 5px; display: inline-block; border: 1px solid #999; }
    </style>
</head>
<body>

    <div id="map"></div>
    
    <div class="app-bar">
        <div class="app-title">‚ö° V·∫¨N H√ÄNH L∆Ø·ªöI ƒêI·ªÜN v1.2</div>
        <button class="btn-menu" onclick="togglePanel()"><i class="fas fa-bars"></i></button>
    </div>

    <button class="btn-gps" onclick="locateUser()"><i class="fas fa-crosshairs"></i></button>

    <div id="control-panel">
        <div class="panel-header">
            <span>T√åM KI·∫æM & ƒêI·ªÄU KHI·ªÇN</span>
            <span onclick="togglePanel()" style="cursor:pointer;font-size:1.5rem;">√ó</span>
        </div>
        <div class="panel-body">
            <label>Ch·ªçn M·∫°ch:</label>
            <select id="circuitSelect" onchange="window.zoomToCircuit()"><option value="">-- To√†n c·∫£nh --</option></select>
            
            <div style="margin: 10px 0; padding: 10px; background: #f5f5f5; border-radius: 6px;">
                Tr·∫°ng th√°i: <span id="status-text" style="font-weight:bold;">---</span>
                <div id="circuit-info" style="font-size:0.85rem; color:#00695c; margin-top:5px;"></div>
            </div>
            
            <button class="action-btn btn-ground" id="btn-grounding" onclick="toggleGrounding()" style="display:none;">üîí ƒê√ìNG TI·∫æP ƒê·ªäA</button>

            <div style="border-top:1px dashed #ccc; margin:15px 0;"></div>
            
            <label>Nh·∫≠p kho·∫£ng c√°ch s·ª± c·ªë (Km):</label>
            <input type="number" id="faultKm" step="0.01" placeholder="V√≠ d·ª•: 3.5" />
            
            <div class="radio-group">
                <label><input type="radio" name="faultDir" value="start" checked> T·ª´ ƒê·∫ßu</label>
                <label><input type="radio" name="faultDir" value="end"> T·ª´ Cu·ªëi</label>
            </div>
            
            <button class="action-btn btn-find" id="btn-find-fault" onclick="window.findFault()">
                <i class="fas fa-search-location"></i> T√åM V·ªä TR√ç
            </button>
            <div id="result" class="warning-msg"></div>
        </div>
    </div>

    <div id="custom-confirm">
        <div class="win-dialog">
            <div class="win-body">
                <i class="fas fa-question-circle" style="font-size:3rem;color:#0078d7;margin-bottom:10px;"></i>
                <div id="win-msg" style="font-size:1.1rem;">...</div>
            </div>
            <div class="win-footer">
                <button class="win-btn btn-yes" id="win-btn-yes" onclick="window.confirmAction()">ƒê·ªìng √Ω</button>
                <button class="win-btn btn-no" onclick="closeWinDialog()">H·ªßy</button>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-polylineoffset@1.1.1/leaflet.polylineoffset.js"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getDatabase, ref, update, onValue } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";
        const firebaseConfig = { apiKey: "AIzaSyCzWjfcD5Dgq7V-i2izb9tKLR6QM6qWPQo", authDomain: "tavietnam-78ae8.firebaseapp.com", projectId: "tavietnam-78ae8", storageBucket: "tavietnam-78ae8.firebasestorage.app", messagingSenderId: "670121705534", appId: "1:670121705534:web:1027ad98550573ad37116f" };
        const app = initializeApp(firebaseConfig);
        window.db = getDatabase(app); window.update = update; window.ref = ref; window.onValue = onValue;
        window.listenCloud();
    </script>

    <script>
        // --- MAP SETUP ---
        let map = L.map('map', { zoomControl: false, maxZoom: 22 }).setView([10.762, 106.660], 12);
        L.control.zoom({ position: 'topright' }).addTo(map);
        L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Esri', maxNativeZoom: 19, maxZoom: 22 }).addTo(map);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { opacity:0.4, maxNativeZoom: 19, maxZoom: 22 }).addTo(map);
        
        map.createPane('areaPane'); map.getPane('areaPane').style.zIndex = 200;
        let layers = { 
            areas: L.layerGroup().addTo(map), 
            main: L.layerGroup().addTo(map), 
            minor: L.layerGroup().addTo(map), 
            important: L.layerGroup().addTo(map), 
            mc: L.layerGroup().addTo(map), 
            fault: L.layerGroup().addTo(map)
        };
        layers.fault.setZIndex(9999);
        
        // --- DATA & STATE ---
        let appData = { poles: {}, segments: {}, circuits: {}, mcStates: {}, grounded: {}, areas: [] }; 
        window.pendingAction = null;
        let currentPath = []; let currentPathTotalDist = 0;
        
        // --- UI FUNCTIONS ---
        function togglePanel() {
            let p = document.getElementById('control-panel');
            p.classList.toggle('active');
        }
        
        function locateUser() {
            map.locate({setView: true, maxZoom: 16});
        }
        map.on('locationfound', function(e) {
            L.circle(e.latlng, {radius: e.accuracy/2, color:'blue', fillOpacity:0.1}).addTo(map);
            L.circleMarker(e.latlng, {radius:5, color:'white', fillColor:'blue', fillOpacity:1}).addTo(map);
        });

        function updateLayerVisibility() {
            let z = map.getZoom();
            if (z < 15) {
                if(map.hasLayer(layers.minor)) map.removeLayer(layers.minor);
                if(map.hasLayer(layers.mc)) map.removeLayer(layers.mc);
            } else {
                if(!map.hasLayer(layers.minor)) map.addLayer(layers.minor);
                if(!map.hasLayer(layers.mc)) map.addLayer(layers.mc);
            }
        }
        map.on('zoomend', updateLayerVisibility);

        // --- CLOUD SYNC ---
        window.listenCloud = function() { 
            window.onValue(window.ref(window.db, 'he_thong_luoi_dien'), snap => { 
                let val = snap.val(); 
                if(val) { 
                    appData = val; 
                    if(!appData.mcStates) appData.mcStates={}; 
                    if(!appData.grounded) appData.grounded={}; 
                    updateUI(); 
                    calculateOffsets(); 
                    renderGlobalMap(); 
                    if(document.getElementById('circuitSelect').value) window.zoomToCircuit(); 
                } 
            }); 
        }

        function updateUI() { 
            const s = document.getElementById('circuitSelect'); 
            let cur = s.value; 
            s.innerHTML = '<option value="">-- To√†n c·∫£nh --</option>'; 
            if(appData.circuits) Object.keys(appData.circuits).forEach(k => { 
                let o=document.createElement('option'); o.value=k; o.text=k; s.add(o); 
            }); 
            s.value = cur; 
        }

        // --- MAP RENDERING LOGIC ---
        function createIcon(type, name, isClosed, sourceVoltage) {
            let cls = 'my-icon icon-tru-do', sz = [12,12], label = '';
            if (type.includes('MC')) { 
                cls = isClosed ? 'my-icon icon-mc-base icon-mc-on' : 'my-icon icon-mc-base icon-mc-off'; 
                sz = [22, 16]; 
                if (sourceVoltage && sourceVoltage.length > 0) { cls += ' icon-mc-source'; sz = [26, 20]; } 
                let parts = name.split('_'); label = parts.length > 1 ? parts[parts.length-1] : name; 
            } 
            else if (type.includes('NEO')) cls = 'my-icon icon-tru-neo'; 
            else if (type.includes('MOC')) { cls = 'my-icon icon-moc'; sz = [8,8]; }
            return L.divIcon({ className: cls, html: label, iconSize: sz });
        }

        function renderGlobalMap() {
            layers.main.clearLayers(); layers.minor.clearLayers(); layers.important.clearLayers(); 
            layers.mc.clearLayers(); layers.areas.clearLayers();
            updateLayerVisibility();

            if(appData.areas) appData.areas.forEach(a => { 
                let c='#9e9e9e'; if(a.type==='TBA') c='#ff9800'; else if(a.type==='CONSTRUCTION') c='#ffeb3b'; else if(a.type==='FOUNDATION') c='#795548'; 
                L.polygon(a.points, {color:c, fillColor:c, fillOpacity:0.3, weight:1}).addTo(layers.areas).bindPopup(`<b>${a.name}</b><br>${a.type}`);
            });
            
            if(appData.poles) for(let l in appData.poles) appData.poles[l].forEach(p => {
                let isMC = p.type.includes('MC'), isMinor = p.type === 'TRU_DO' || p.type === 'MOC'; 
                let target = isMC ? layers.mc : (isMinor ? layers.minor : layers.important);
                let isClosed = isMC ? (appData.mcStates[p.name] !== false) : true;
                let marker = L.marker([p.lat, p.lng], { icon: createIcon(p.type, p.name, isClosed, p.sourceVoltage), zIndexOffset: isMC ? 1000 : 0 }).addTo(target);
                
                if (isMC) {
                    marker.on('click', () => {
                        let currentState = appData.mcStates[p.name] !== false; 
                        document.getElementById('win-msg').innerHTML = `ƒêi·ªÅu khi·ªÉn m√°y c·∫Øt <b>${p.name}</b>?<br><br>Tr·∫°ng th√°i: <b>${currentState?"ƒêANG ƒê√ìNG":"ƒêANG M·ªû"}</b>`;
                        window.pendingAction = { type: 'mc', name: p.name }; 
                        document.getElementById('custom-confirm').style.display = 'flex';
                    });
                } else {
                    marker.bindPopup(`<b>${p.name}</b><br>${l}`);
                }
            });

            if(appData.circuits) Object.keys(appData.circuits).forEach(cid => drawSingleCircuit(cid, false));
        }

        // --- CIRCUIT & FAULT LOGIC ---
        function drawSingleCircuit(circuitId, calcPath, excludeSegId, simulationOnly = false) {
            const segs = appData.circuits[circuitId]; if(!segs) return;
            let connectedMCs = []; 
            segs.forEach(item => { 
                let def = appData.segments[item.segId]; 
                if(def) { 
                    let p1 = getPoleExact(def.lineFrom, def.poleFrom), p2 = getPoleExact(def.lineTo, def.poleTo); 
                    if(p1 && p1.type.includes('MC')) connectedMCs.push(p1); 
                    if(p2 && p2.type.includes('MC')) connectedMCs.push(p2); 
                } 
            });
            
            let activeVoltage = null; 
            let isGrounded = appData.grounded ? appData.grounded[circuitId] : false;
            let activeSources = connectedMCs.filter(mc => (appData.mcStates[mc.name] !== false) && mc.sourceVoltage);
            if (activeSources.length > 0) { 
                activeSources.sort((a,b) => { let vA = parseInt(a.sourceVoltage)||0, vB = parseInt(b.sourceVoltage)||0; return vB - vA; }); 
                activeVoltage = activeSources[0].sourceVoltage; 
            }
            
            let color = '#000000', statusText = "M·∫§T ƒêI·ªÜN";
            if (isGrounded) { color = '#2196f3'; statusText = "ƒêANG TI·∫æP ƒê·ªäA"; } 
            else if (activeVoltage) { 
                if (activeVoltage.includes('110')) { color = '#388e3c'; statusText = "C√ì ƒêI·ªÜN (110kV)"; } 
                else if (activeVoltage.includes('220')) { color = '#d32f2f'; statusText = "C√ì ƒêI·ªÜN (220kV)"; } 
                else if (activeVoltage.includes('500')) { color = '#0d47a1'; statusText = "C√ì ƒêI·ªÜN (500kV)"; } 
            }
            
            if(calcPath) { 
                if(!simulationOnly) {
                    document.getElementById('status-text').innerHTML = `<span style="color:${color}">${statusText}</span>`; 
                    let btnG = document.getElementById('btn-grounding'); 
                    if(!activeVoltage || isGrounded) { 
                        btnG.style.display = 'flex'; 
                        btnG.innerHTML = isGrounded ? "<i class='fas fa-lock-open'></i> M·ªû TI·∫æP ƒê·ªäA" : "<i class='fas fa-lock'></i> ƒê√ìNG TI·∫æP ƒê·ªäA"; 
                        btnG.style.background = isGrounded ? "#7cb342" : "#0288d1"; 
                    } else { btnG.style.display = 'none'; }
                }
                currentPath=[]; currentPathTotalDist=0; 
            }
            
            segs.forEach(item => {
                let def = appData.segments[item.segId]; if(!def) return; 
                let pts = getPointsForSegment(def); 
                
                let p1=getPoleExact(def.lineFrom, def.poleFrom)||getPoleGlobal(def.poleFrom);
                let p2=getPoleExact(def.lineTo, def.poleTo)||getPoleGlobal(def.poleTo);
                let offset = 0;
                if(p1 && p2 && !simulationOnly) {
                    let key = getSegmentKey(p1, p2); let list = segmentCounts[key];
                    if (list && list.length > 1) { let idx = list.indexOf(circuitId); if (idx !== -1) { let center = (list.length - 1) / 2; offset = (idx - center) * 6; } }
                }

                if(pts.length) { 
                    if (!simulationOnly) {
                        let isCable=def.type.includes("NGAM"); 
                        L.polyline(pts.map(p=>[p.lat,p.lng]), { color: color, weight: calcPath?5:3, opacity: calcPath?1:0.8, dashArray: isCable?"5,5":null, offset: offset })
                        .addTo(layers.main)
                        .bindPopup(`<b>${circuitId}</b><br>${statusText}`);
                    }
                    if(calcPath) pts.forEach((p,i)=>{ 
                        if(i>0) currentPathTotalDist+=getDist(pts[i-1].lat,pts[i-1].lng,p.lat,p.lng); 
                        currentPath.push({lat: p.lat, lng: p.lng, accDist:currentPathTotalDist, name: p.name}); 
                    }); 
                }
            });
        }
        
        // --- HELPER FUNCTIONS ---
        let segmentCounts = {};
        function getSegmentKey(p1, p2) { let k1=p1.lat+"_"+p1.lng, k2=p2.lat+"_"+p2.lng; return (k1<k2)?(k1+"|"+k2):(k2+"|"+k1); }
        function calculateOffsets() { segmentCounts={}; if(appData.circuits) Object.keys(appData.circuits).forEach(cid=>{ appData.circuits[cid].forEach(item=>{ let def=appData.segments[item.segId]; if(def){ let p1=getPoleExact(def.lineFrom,def.poleFrom), p2=getPoleExact(def.lineTo,def.poleTo); if(p1&&p2){ let k=getSegmentKey(p1,p2); if(!segmentCounts[k]) segmentCounts[k]=[]; segmentCounts[k].push(cid); } } }); }); }
        function getPoleExact(line, name) { if(!appData.poles[line]) return null; return appData.poles[line].find(p=>String(p.name).toUpperCase()===String(name).toUpperCase()); }
        function getPoleGlobal(name) { for(let l in appData.poles) { let p=appData.poles[l].find(p=>String(p.name).toUpperCase()===String(name).toUpperCase()); if(p) return {...p, foundRoute:l}; } return null; }
        function getDist(lat1,lon1,lat2,lon2) { const R=6371000, dLat=(lat2-lat1)*Math.PI/180, dLon=(lon2-lon1)*Math.PI/180; const a=Math.sin(dLat/2)*Math.sin(dLat/2)+Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.sin(dLon/2)*Math.sin(dLon/2); return R*2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a)); }
        
        function getPointsForSegment(seg) {
            if(!seg) return [];
            let p1 = getPoleExact(seg.lineFrom, seg.poleFrom) || getPoleGlobal(seg.poleFrom);
            let p2 = getPoleExact(seg.lineTo, seg.poleTo) || getPoleGlobal(seg.poleTo);
            if(!p1 || !p2) return [];
            let r1 = p1.foundRoute || seg.lineFrom;
            let r2 = p2.foundRoute || seg.lineTo;
            if (r1 === r2) {
                let routePoles = appData.poles[r1];
                if (routePoles) {
                    let i1 = routePoles.findIndex(p => p.name === p1.name);
                    let i2 = routePoles.findIndex(p => p.name === p2.name);
                    if (i1 !== -1 && i2 !== -1) {
                        let segmentPoles = (i1 <= i2) ? routePoles.slice(i1, i2 + 1) : routePoles.slice(i2, i1 + 1).reverse();
                        return segmentPoles.map(p => ({lat: p.lat, lng: p.lng, name: p.name}));
                    }
                }
            }
            return [{lat: p1.lat, lng: p1.lng, name: p1.name}, {lat: p2.lat, lng: p2.lng, name: p2.name}];
        }

        // --- FIND FAULT & CONTROLS ---
        window.zoomToCircuit = function() { 
            let id = document.getElementById('circuitSelect').value; 
            layers.main.clearLayers(); renderGlobalMap(); 
            document.getElementById('btn-grounding').style.display = 'none'; 
            if(!id) { document.getElementById('status-text').innerText = "---"; return; } 
            drawSingleCircuit(id, true); 
            document.getElementById('circuit-info').innerText = `T·ªïng d√†i: ${(currentPathTotalDist/1000).toFixed(3)} km`; 
            if(currentPath.length) map.fitBounds(currentPath.map(p=>[p.lat,p.lng])); 
        }

        window.findFault = function() { 
            let btn = document.getElementById('btn-find-fault');
            let oldText = btn.innerHTML;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> ƒêang t√≠nh to√°n...'; btn.disabled = true;

            setTimeout(() => {
                try {
                    layers.fault.clearLayers(); 
                    let res = document.getElementById('result'); 
                    res.style.display='none'; 
                    let faultBox = document.getElementById('fault-info-box');
                    if(faultBox) faultBox.style.display='none'; 

                    let kmInput = parseFloat(document.getElementById('faultKm').value); 
                    let direction = document.querySelector('input[name="faultDir"]:checked').value; 
                    let cName = document.getElementById('circuitSelect').value; 

                    currentPath = []; 
                    if(cName) drawSingleCircuit(cName, true, null, true); 

                    if(isNaN(kmInput) || currentPath.length<2) { 
                        res.style.display='block'; res.className='warning-msg'; res.innerText='Vui l√≤ng ch·ªçn m·∫°ch tr∆∞·ªõc!'; 
                        btn.innerHTML = oldText; btn.disabled = false; return; 
                    } 
                    
                    let totalKm = currentPathTotalDist / 1000;
                    if(kmInput > totalKm) { 
                        res.style.display='block'; res.className='warning-msg'; res.innerText=`‚ö†Ô∏è Km nh·∫≠p (${kmInput}) > Chi·ªÅu d√†i m·∫°ch (${totalKm.toFixed(3)} km)!`; 
                        btn.innerHTML = oldText; btn.disabled = false; return; 
                    }
                    
                    let targetDist = direction==='end' ? currentPathTotalDist-(kmInput*1000) : kmInput*1000; 
                    
                    let found = false;
                    for(let i=1; i<currentPath.length; i++) { 
                        let p1=currentPath[i-1], p2=currentPath[i]; 
                        let d1=p1.accDist, d2=p2.accDist;
                        if(targetDist>=(d1-0.1) && targetDist<=(d2+0.1)) { 
                            found = true;
                            let ratio = (d2 > d1) ? (targetDist-d1)/(d2-d1) : 0; 
                            let lat = p1.lat + (p2.lat-p1.lat)*ratio, lng = p1.lng + (p2.lng-p1.lng)*ratio; 
                            
                            // Find nearest names
                            let n1 = "ƒêi·ªÉm ƒë·∫ßu", n2 = "ƒêi·ªÉm cu·ªëi";
                            for (let j = i-1; j >= 0; j--) { if (currentPath[j].name) { n1 = currentPath[j].name; break; } }
                            for (let j = i; j < currentPath.length; j++) { if (currentPath[j].name) { n2 = currentPath[j].name; break; } }

                            if(faultBox) {
                                faultBox.style.display='block'; 
                                document.getElementById('fi-name').innerText=cName; 
                                document.getElementById('fi-dist').innerText=`${kmInput} km`; 
                                document.getElementById('fi-seg').innerHTML=`Gi·ªØa: <b>${n1}</b> <i class="fas fa-arrow-right"></i> <b>${n2}</b>`; 
                                document.getElementById('fi-addr').innerHTML=`<a href="https://www.google.com/maps?q=${lat},${lng}" target="_blank">Google Maps</a>`; 
                                fetchWeather(lat, lng);
                            }
                            
                            L.marker([lat,lng], {
                                zIndexOffset: 9999, 
                                icon: L.divIcon({ html:'<i class="fas fa-bolt fault-marker"></i>', className:'d', iconSize: [30, 30], iconAnchor: [15, 30] })
                            }).addTo(layers.fault).bindPopup("<b>S·ª∞ C·ªê T·∫†I ƒê√ÇY</b>").openPopup(); 
                            
                            map.setView([lat, lng], 18); 
                            togglePanel(); // Close panel on mobile
                            break; 
                        } 
                    }
                    if(!found) {
                         res.style.display='block'; res.className='warning-msg'; res.innerText = `Kh√¥ng t√¨m th·∫•y ƒëi·ªÉm (L·ªói d·ªØ li·ªáu)`; 
                    }
                } catch(e) { console.error(e); alert("L·ªói: " + e.message); } finally { btn.innerHTML = oldText; btn.disabled = false; }
            }, 50); 
        }

        // --- WIND DIRECTION HELPER ---
        function getWindDirection(degrees) {
            const directions = ['B·∫Øc', 'ƒê√¥ng B·∫Øc', 'ƒê√¥ng', 'ƒê√¥ng Nam', 'Nam', 'T√¢y Nam', 'T√¢y', 'T√¢y B·∫Øc'];
            // Chia 360 ƒë·ªô th√†nh 8 h∆∞·ªõng (m·ªói h∆∞·ªõng 45 ƒë·ªô), offset 22.5 ƒë·ªô ƒë·ªÉ canh gi·ªØa
            const index = Math.round(degrees / 45) % 8;
            return directions[index];
        }

        async function fetchWeather(lat, lng) {
            let infoBox = document.getElementById('fault-weather');
            if(!infoBox) {
                let div = document.createElement('div'); div.id = 'fault-weather'; div.className = 'weather-info';
                document.getElementById('fault-info-box').appendChild(div); infoBox = div;
            }
            infoBox.innerHTML = '<i>‚è≥ ƒêang t·∫£i th·ªùi ti·∫øt...</i>';
            try {
                const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&current=temperature_2m,precipitation,weather_code,wind_speed_10m,wind_direction_10m&timezone=auto`;
                const res = await fetch(url);
                const data = await res.json();
                if (data.current) {
                    let code = data.current.weather_code;
                    let isStorm = [95, 96, 99].includes(code);
                    let condition = "N·∫Øng/√çt m√¢y";
                    if(code > 3) condition = "Nhi·ªÅu m√¢y";
                    if(code >= 51) condition = "M∆∞a";
                    if(isStorm) condition = "D√¥ng s√©t";
                    
                    let windDeg = data.current.wind_direction_10m;
                    let windDirText = getWindDirection(windDeg);
                    // Rotate icon: 0deg in CSS is Up (North). 
                    // If wind blows FROM North (0 deg), it blows TO South (180 deg).
                    // So we rotate by windDeg + 180.
                    let iconRotation = windDeg + 180; 

                    let html = `
                        <div class="weather-row">
                            <span><i class="fas fa-wind"></i> Gi√≥:</span> 
                            <div style="display:flex;align-items:center;gap:5px;">
                                <b>${data.current.wind_speed_10m} km/h</b>
                                <div style="border:1px solid #999; border-radius:50%; width:20px; height:20px; display:flex; justify-content:center; align-items:center; background:white;">
                                    <i class="fas fa-arrow-up" style="transform: rotate(${iconRotation}deg); color:#333; font-size:12px;" title="H∆∞·ªõng gi√≥"></i>
                                </div>
                                <small>(${windDirText})</small>
                            </div>
                        </div>
                        <div class="weather-row"><span><i class="fas fa-cloud"></i> Tr·ªùi:</span> <b>${condition}</b></div>
                        <div class="weather-row"><span><i class="fas fa-temperature-high"></i> Nhi·ªát ƒë·ªô:</span> <b>${data.current.temperature_2m}¬∞C</b></div>
                    `;
                    if(isStorm) html += `<div class="weather-alert"><i class="fas fa-bolt"></i> C·∫¢NH B√ÅO: C√ì D√îNG S√âT!</div>`;
                    infoBox.innerHTML = html;
                }
            } catch (e) { infoBox.innerHTML = 'L·ªói l·∫•y th·ªùi ti·∫øt.'; }
        }

        window.confirmAction = function() {
            if (!window.pendingAction) { closeWinDialog(); return; }
            if (window.pendingAction.type === 'mc') { 
                window.update(window.ref(window.db, 'he_thong_luoi_dien/mcStates'), { [window.pendingAction.name]: !(appData.mcStates[window.pendingAction.name] !== false) }); 
            }
            closeWinDialog();
        }
        window.closeWinDialog = function() { document.getElementById('custom-confirm').style.display = 'none'; window.pendingAction = null; }
        window.toggleGrounding = function() { let cid = document.getElementById('circuitSelect').value; if(!cid) return; let currentG = appData.grounded ? appData.grounded[cid] : false; window.update(window.ref(window.db, 'he_thong_luoi_dien/grounded'), { [cid]: !currentG }); }

        // --- ADD LEGEND & FAULT BOX ---
        var legendControl = L.control({position: 'bottomright'});
        legendControl.onAdd = function (map) {
            var div = L.DomUtil.create('div', 'legend');
            div.innerHTML = `<div class="legend-item"><span class="legend-icon" style="background:#ff0000;"></span> ƒê√≥ng (ƒê·ªè)</div><div class="legend-item"><span class="legend-icon" style="background:#388e3c;"></span> C·∫Øt (Xanh)</div>`;
            return div;
        };
        legendControl.addTo(map);

        var faultControl = L.control({position: 'bottomright'});
        faultControl.onAdd = function (map) {
            var div = L.DomUtil.create('div', 'fault-box');
            div.id = "fault-info-box";
            div.innerHTML = `<div class="fault-header"><span><i class="fas fa-exclamation-triangle"></i> S·ª∞ C·ªê</span><button class="btn-close-fault" onclick="document.getElementById('fault-info-box').style.display='none'">X</button></div><div class="fault-row"><span class="fault-label">M·∫°ch:</span> <span id="fi-name"></span></div><div class="fault-row"><span class="fault-label">C√°ch ngu·ªìn:</span> <span id="fi-dist"></span></div><div class="fault-row"><span class="fault-label">V·ªã tr√≠:</span> <span id="fi-seg"></span></div><div class="fault-row"><span id="fi-addr"></span></div>`;
            return div;
        };
        faultControl.addTo(map);

    </script>
</body>
</html>

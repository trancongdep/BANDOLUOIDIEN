<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Hệ Thống Lưới Điện - V2.0 Topology</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    
    <style>
        /* CSS CƠ BẢN */
        body { margin: 0; padding: 0; font-family: 'Segoe UI', sans-serif; display: flex; flex-direction: column; height: 100vh; background: #f0f2f5; overflow: hidden; }
        #map { position: absolute; top: 0; left: 0; right: 0; bottom: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* SIDEBAR & UI */
        #menu-toggle { position: absolute; top: 10px; left: 10px; z-index: 2000; background: #004d40; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.3); font-weight: bold; }
        #sidebar { position: fixed; top: 0; left: -100%; width: 90%; max-width: 450px; bottom: calc(30px + env(safe-area-inset-bottom, 10px)); background: white; z-index: 3000; box-shadow: 2px 0 10px rgba(0,0,0,0.3); transition: left 0.3s ease-in-out; display: flex; flex-direction: column; }
        #sidebar.active { left: 0; }
        .header { background: #004d40; color: white; padding: 15px; display: flex; justify-content: space-between; align-items: center; }
        .header h2 { margin: 0; font-size: 1.1rem; }
        .close-btn { background: none; border: none; color: white; font-size: 1.5rem; cursor: pointer; }
        .content { padding: 10px; overflow-y: auto; flex: 1; background: #fafafa; }
        .footer { position: fixed; bottom: 0; left: 0; width: 100%; min-height: 30px; padding-top: 5px; padding-bottom: env(safe-area-inset-bottom, 10px); background: #212121; color: #eceff1; display: flex; align-items: center; justify-content: center; font-size: 0.75rem; border-top: 3px solid #ff6f00; z-index: 4000; }
        
        /* COMPONENTS */
        .panel { padding: 10px; background: white; border-bottom: 1px solid #ddd; margin-bottom: 10px; }
        label { font-weight: 600; font-size: 0.85rem; display: block; margin: 8px 0 4px; color: #333; }
        input, select { width: 100%; padding: 8px; margin-bottom: 5px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; }
        button.action-btn { padding: 10px; width: 100%; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; margin-bottom: 10px; color: white; background: #00796b; }
        
        /* ICONS */
        .my-icon { border: 1px solid white; box-shadow: 1px 1px 3px rgba(0,0,0,0.6); text-align: center; font-size: 9px; display: flex; justify-content: center; align-items: center; color: white; font-weight: bold; }
        
        /* NGUỒN (SOURCE) */
        .icon-source { 
            border-radius: 50%; border: 2px solid white; color: white; font-weight: bold; font-size: 10px;
            display: flex; justify-content: center; align-items: center; box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        
        /* MÁY CẮT (SỐ HIỆU) */
        .icon-mc-on { background: #d32f2f; border: 2px solid white; border-radius: 2px; font-size: 9px; z-index: 2000 !important; color: white; }
        .icon-mc-off { background: #388e3c; border: 2px solid white; border-radius: 2px; font-size: 9px; z-index: 2000 !important; color: white; }

        .icon-tru-neo { background: #ff6f00; transform: rotate(45deg); border-radius: 2px; }
        .icon-tru-do { background: #1976d2; border-radius: 50%; }

        /* LEGEND */
        .legend { background: rgba(255, 255, 255, 0.95); padding: 10px; border-radius: 5px; box-shadow: 0 0 15px rgba(0, 0, 0, 0.2); font-size: 0.75rem; margin-bottom: 45px !important; margin-right: 10px; }
        .legend-item { display: flex; align-items: center; margin-bottom: 4px; }
        .legend-icon { width: 14px; height: 14px; margin-right: 6px; border: 1px solid #999; }

        /* DIALOG */
        #custom-confirm { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 9999; justify-content: center; align-items: center; backdrop-filter: blur(2px); }
        .win-dialog { background: #f0f0f0; width: 90%; max-width: 400px; border-radius: 4px; overflow: hidden; box-shadow: 0 4px 20px rgba(0,0,0,0.4); animation: popIn 0.2s ease-out; }
        @keyframes popIn { from { transform: scale(0.9); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .win-header { background: white; padding: 10px 15px; display: flex; justify-content: space-between; font-weight: bold; border-bottom: 1px solid #ddd; }
        .win-body { padding: 20px; background: white; display: flex; align-items: center; gap: 15px; }
        .win-icon { font-size: 2rem; color: #0078d7; }
        .win-footer { padding: 10px 15px; background: #f3f3f3; display: flex; justify-content: flex-end; gap: 10px; border-top: 1px solid #ddd; }
        .win-btn { padding: 6px 20px; border: 1px solid #ccc; cursor: pointer; }
        .win-btn.primary { background: #0078d7; color: white; border-color: #005a9e; }
    </style>
</head>
<body>

    <div id="map"></div>
    <button id="menu-toggle" onclick="openSidebar()"><i class="fas fa-bars"></i> MENU</button>

    <div id="custom-confirm">
        <div class="win-dialog">
            <div class="win-header"><span>Xác nhận</span><button style="border:none;background:none;font-size:1.2rem;cursor:pointer;" onclick="closeWinDialog()">×</button></div>
            <div class="win-body"><i class="fas fa-question-circle win-icon"></i><span id="win-msg">...</span></div>
            <div class="win-footer"><button class="win-btn primary" id="win-btn-yes">Đồng ý</button><button class="win-btn" onclick="closeWinDialog()">Hủy</button></div>
        </div>
    </div>

    <div id="sidebar">
        <div class="header"><h2>HỆ THỐNG ĐIỆN V2.0</h2><button class="close-btn" onclick="closeSidebar()">×</button></div>
        <div class="content">
            <div class="panel">
                <label>1. Cập nhật Dữ liệu:</label>
                <input type="file" id="excelFile" accept=".csv, .xlsx" multiple />
                <button class="action-btn" onclick="window.analyzeFiles()">Nạp & Kiểm tra</button>
                <div id="upload-actions" style="display:none;">
                    <button class="action-btn" style="background:#2e7d32;" onclick="window.showUploadConfirm('merge')">GỘP DỮ LIỆU</button>
                    <button class="action-btn" style="background:#c62828;" onclick="window.showUploadConfirm('replace')">XÓA & GHI MỚI</button>
                </div>
            </div>
            <div class="panel">
                <label>2. Tìm Mạch/Trạm:</label>
                <select id="circuitSelect" onchange="window.zoomToTarget()"><option value="">-- Toàn cảnh --</option></select>
                <div style="margin-top:10px; font-weight:bold; color:#00695c;" id="status-text">---</div>
            </div>
        </div>
    </div>

    <div class="footer">Copyright TCD software @2026 - Version 2.0 (Topology)</div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-polylineoffset@1.1.1/leaflet.polylineoffset.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getDatabase, ref, set, update, onValue } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";
        const firebaseConfig = { apiKey: "AIzaSyCzWjfcD5Dgq7V-i2izb9tKLR6QM6qWPQo", authDomain: "tavietnam-78ae8.firebaseapp.com", projectId: "tavietnam-78ae8", storageBucket: "tavietnam-78ae8.firebasestorage.app", messagingSenderId: "670121705534", appId: "1:670121705534:web:1027ad98550573ad37116f" };
        const app = initializeApp(firebaseConfig);
        window.db = getDatabase(app); window.set = set; window.update = update; window.ref = ref; window.onValue = onValue;
        window.listenCloud();
    </script>

    <script>
        // --- MAP SETUP ---
        let map = L.map('map', { zoomControl: false, maxZoom: 22 }).setView([16.0, 106.0], 6);
        L.control.zoom({ position: 'topright' }).addTo(map);
        
        var ExtentControl = L.Control.extend({
            options: { position: 'topright' },
            onAdd: function(map) {
                var btn = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
                btn.innerHTML = '<a href="#" title="Xem toàn bộ" style="background:white; width:30px; height:30px; display:flex; align-items:center; justify-content:center; font-size:18px; color:black; text-decoration:none;"><i class="fas fa-globe"></i></a>';
                btn.onclick = (e) => { e.preventDefault(); if(appData.poles) { let b=[]; for(let k in appData.poles) appData.poles[k].forEach(p=>b.push([p.lat,p.lng])); map.fitBounds(b); }};
                return btn;
            }
        });
        map.addControl(new ExtentControl());

        L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {attribution: 'Esri'}).addTo(map);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {opacity:0.4}).addTo(map);

        // --- LAYERS ---
        // zIndex: Busbar(400) -> Line(450) -> Point(500) -> MC(600) -> Source(700)
        map.createPane('busbarPane'); map.getPane('busbarPane').style.zIndex = 400;
        map.createPane('linePane'); map.getPane('linePane').style.zIndex = 450;

        let layers = {
            busbar: L.layerGroup().addTo(map),
            line: L.layerGroup().addTo(map),
            points: L.layerGroup().addTo(map), // Trụ đỡ
            mc: L.layerGroup().addTo(map),
            source: L.layerGroup().addTo(map)
        };

        // --- DATA ---
        let appData = { poles: {}, segments: {}, mcStates: {}, adjList: {} }; 
        let stagingData = null;
        let activeBusbars = {}; // Cache vị trí thanh cái {PointName: [LineStart, LineEnd]}

        // --- COLORS ---
        const VOLTAGE_COLORS = {
            500: '#2196F3', // Xanh dương
            220: '#F44336', // Đỏ
            110: '#2E7D32', // Xanh lá đậm
            35: '#FF9800',  // Cam
            22: '#FFC107',  // Vàng
            0: '#000000'    // Mất điện
        };

        // --- UI LOGIC ---
        function openSidebar() { document.getElementById('sidebar').classList.add('active'); }
        function closeSidebar() { document.getElementById('sidebar').classList.remove('active'); }
        map.on('click', closeSidebar);

        // --- DIALOG ---
        let pendingAction = null; 
        window.showMCConfirm = function(mcName) {
            let cur = appData.mcStates[mcName] !== false; 
            document.getElementById('win-msg').innerHTML = `Bạn muốn <b>${cur?"MỞ":"ĐÓNG"}</b> máy cắt <b>${mcName}</b>?`;
            pendingAction = { type: 'mc', name: mcName };
            document.getElementById('custom-confirm').style.display = 'flex';
        }
        window.showUploadConfirm = function(mode) {
            document.getElementById('win-msg').innerHTML = mode==='merge'?"Gộp dữ liệu?":"Xóa cũ và ghi mới?";
            pendingAction = { type: 'upload', mode: mode };
            document.getElementById('custom-confirm').style.display = 'flex';
        }
        window.closeWinDialog = function() { document.getElementById('custom-confirm').style.display = 'none'; pendingAction=null; }
        document.getElementById('win-btn-yes').onclick = function() {
            if(!pendingAction) return;
            if(pendingAction.type==='mc') window.update(window.ref(window.db, 'he_thong_luoi_dien/mcStates'), {[pendingAction.name]: !(appData.mcStates[pendingAction.name]!==false)});
            if(pendingAction.type==='upload') executeUpload(pendingAction.mode);
            closeWinDialog();
        };

        // --- DATA PROCESSING ---
        function getCol(row, candidates) { let k=Object.keys(row); for(let c of candidates){ let m=k.find(key=>key.trim().replace(/^\uFEFF/,'')===c); if(m) return m; } return null; }
        
        window.analyzeFiles = function() {
            const input = document.getElementById('excelFile');
            if(!input.files.length) return alert("Chưa chọn file");
            Promise.all(Array.from(input.files).map(readFile)).then(res => processSheets(Object.assign({}, ...res)));
        }
        function readFile(file) { return new Promise(r => { const rd=new FileReader(); rd.onload=e=>{ const w=XLSX.read(new Uint8Array(e.target.result),{type:'array'}); let s={}; w.SheetNames.forEach(n=>s[n]=XLSX.utils.sheet_to_json(w.Sheets[n])); r(s); }; rd.readAsArrayBuffer(file); }); }

        function processSheets(sheets) {
            const sPoles=Object.keys(sheets).find(n=>n.includes("TOA_DO"));
            const sSegs=Object.keys(sheets).find(n=>n.includes("DM_DOAN"));
            if(!sPoles||!sSegs) return alert("Thiếu TOA_DO hoặc DM_DOAN!");

            let data = { poles: {}, segments: {}, mcStates: {} }; // Không cần circuits nữa cho logic màu
            
            // 1. POLES
            let pData = sheets[sPoles];
            let cMa=getCol(pData[0],["MA_TUYEN"]), cTen=getCol(pData[0],["TEN_DIEM","TEN_TRU"]), cLat=getCol(pData[0],["LAT"]), cLng=getCol(pData[0],["LONG"]), cLoai=getCol(pData[0],["LOAI_DIEM"]), cVol=getCol(pData[0],["DIEN_AP"]);
            
            pData.forEach(r => {
                let l=String(r[cMa]||"OTHER").trim(), n=String(r[cTen]).trim();
                let type = cLoai ? String(r[cLoai]).trim().toUpperCase() : "TRU_DO";
                let volt = cVol ? parseInt(r[cVol]) : 0;
                
                if(r[cLat]) {
                    if(!data.poles[l]) data.poles[l]=[];
                    data.poles[l].push({ name:n, lat:parseFloat(r[cLat]), lng:parseFloat(r[cLng]), type:type, voltage:volt });
                    if(type==='MC') data.mcStates[n] = true; // Mặc định đóng
                }
            });

            // 2. SEGMENTS
            let sData = sheets[sSegs];
            let cId=getCol(sData[0],["MA_DOAN"]), cT1=getCol(sData[0],["TUYEN_TU"]), cN1=getCol(sData[0],["TRU_TU","DIEM_TU"]), cT2=getCol(sData[0],["TUYEN_DEN"]), cN2=getCol(sData[0],["TRU_DEN","DIEM_DEN"]), cL=getCol(sData[0],["LOAI"]);
            
            sData.forEach(r => {
                let id = r[cId];
                if(id) {
                    data.segments[id] = {
                        id: id,
                        type: cL ? String(r[cL]).trim().toUpperCase() : "NOI", // THANH_CAI, NGAM, NOI
                        fromLine: r[cT1], fromNode: String(r[cN1]).trim(),
                        toLine: r[cT2], toNode: String(r[cN2]).trim()
                    };
                }
            });

            stagingData = data;
            document.getElementById('upload-actions').style.display = "block";
            alert("Kiểm tra dữ liệu xong. Vui lòng chọn Gộp hoặc Ghi mới.");
        }

        function executeUpload(mode) {
            if(!stagingData) return;
            let refRoot = window.ref(window.db, 'he_thong_luoi_dien');
            if(mode === 'replace') {
                window.set(refRoot, stagingData).then(()=>alert("Đã thay thế!"));
            } else {
                let updates = {};
                Object.keys(stagingData.poles).forEach(k => updates[`poles/${k}`] = stagingData.poles[k]);
                Object.keys(stagingData.segments).forEach(k => updates[`segments/${k}`] = stagingData.segments[k]);
                // Merge MC states safely? No, just overwrite init
                if(stagingData.mcStates) Object.keys(stagingData.mcStates).forEach(k => updates[`mcStates/${k}`] = true);
                window.update(refRoot, updates).then(()=>alert("Đã gộp!"));
            }
        }

        // --- TOPOLOGY TRACING ALGORITHM ---
        function buildAdjacencyList() {
            appData.adjList = {};
            activeBusbars = {}; // Reset busbar map
            
            // Build map of Node -> Coordinates/Info
            let nodeMap = {};
            for(let l in appData.poles) {
                appData.poles[l].forEach(p => nodeMap[p.name] = p);
            }

            // Define Busbars first (segments with type THANH_CAI)
            if(appData.segments) {
                Object.values(appData.segments).forEach(seg => {
                    if(seg.type === 'THANH_CAI') {
                        // Lưu thông tin thanh cái để tính toán vẽ vuông góc sau này
                        // Thanh cái kết nối 2 điểm nối (DIEM_NOI)
                        let p1 = nodeMap[seg.fromNode];
                        let p2 = nodeMap[seg.toNode];
                        if(p1 && p2) {
                            // Lưu vector thanh cái
                            let key1 = seg.fromNode, key2 = seg.toNode;
                            activeBusbars[key1] = { p1, p2 };
                            activeBusbars[key2] = { p1, p2 };
                        }
                    }
                    
                    // Add to Graph
                    if(!appData.adjList[seg.fromNode]) appData.adjList[seg.fromNode] = [];
                    if(!appData.adjList[seg.toNode]) appData.adjList[seg.toNode] = [];
                    
                    appData.adjList[seg.fromNode].push({ to: seg.toNode, id: seg.id, type: seg.type });
                    appData.adjList[seg.toNode].push({ to: seg.fromNode, id: seg.id, type: seg.type });
                });
            }
            return nodeMap;
        }

        function tracePowerFlow(nodeMap) {
            // 1. Reset color of all segments to 0 (Black)
            let segmentColors = {}; // segId -> voltage
            if(appData.segments) Object.keys(appData.segments).forEach(k => segmentColors[k] = 0);

            // 2. Find Sources
            let queue = [];
            for(let l in appData.poles) {
                appData.poles[l].forEach(p => {
                    if(p.type === 'NGUON') {
                        queue.push({ node: p.name, voltage: p.voltage });
                    }
                });
            }

            // 3. BFS
            let visited = {}; // node -> maxVoltageSeen
            
            while(queue.length > 0) {
                let curr = queue.shift();
                let u = curr.node;
                let volt = curr.voltage;

                // Nếu đã đến nút này với cấp điện áp cao hơn hoặc bằng -> bỏ qua
                if (visited[u] >= volt) continue;
                visited[u] = volt;

                // Duyệt các cạnh nối
                let neighbors = appData.adjList[u] || [];
                neighbors.forEach(edge => {
                    // Check MC status
                    let canPass = true;
                    let nextNodeInfo = nodeMap[edge.to];
                    let currNodeInfo = nodeMap[u];

                    // Nếu đi QUA MC (u là MC hoặc to là MC)? 
                    // Logic: MC là một điểm. Nếu dòng điện đến MC, nó chỉ đi tiếp nếu MC đóng.
                    if (currNodeInfo.type === 'MC') {
                        if (appData.mcStates[u] === false) canPass = false;
                    }
                    // (Lưu ý: Nếu MC nằm GIỮA đoạn dây thì mô hình dữ liệu phải tách đoạn dây thành 2 đoạn nối vào MC)
                    
                    if (canPass) {
                        // Nhuộm màu dây
                        if (segmentColors[edge.id] < volt) segmentColors[edge.id] = volt;
                        
                        // Lan truyền tiếp
                        queue.push({ node: edge.to, voltage: volt });
                    }
                });
            }
            return segmentColors;
        }

        // --- RENDER V2.0 ---
        window.listenCloud = function() {
            window.onValue(window.ref(window.db, 'he_thong_luoi_dien'), snap => {
                let val = snap.val();
                if(val) {
                    appData = val;
                    if(!appData.mcStates) appData.mcStates = {};
                    let nodeMap = buildAdjacencyList();
                    let segColors = tracePowerFlow(nodeMap);
                    renderMap(nodeMap, segColors);
                    updateUI();
                }
            });
        }

        function updateUI() {
            // Update dropdown list based on Routes (Tuyen)
            const s = document.getElementById('circuitSelect');
            s.innerHTML = '<option value="">-- Toàn cảnh --</option>';
            if(appData.poles) Object.keys(appData.poles).forEach(k => {
                let o = document.createElement('option'); o.value = k; o.text = k; s.add(o);
            });
        }

        // --- GEOMETRY HELPER: PERPENDICULAR PROJECTION ---
        function getProjectedPoint(P, A, B) {
            // Project point P onto line segment AB. 
            // P, A, B are {lat, lng} objects
            // Convert to simple x,y for math (approximation is fine for visual)
            let x = P.lng, y = P.lat;
            let x1 = A.lng, y1 = A.lat;
            let x2 = B.lng, y2 = B.lat;

            let A_to_P = { x: x - x1, y: y - y1 };
            let A_to_B = { x: x2 - x1, y: y2 - y1 };
            let AB_sq = A_to_B.x*A_to_B.x + A_to_B.y*A_to_B.y;
            if (AB_sq === 0) return A; // A and B are same

            let dot = A_to_P.x*A_to_B.x + A_to_P.y*A_to_B.y;
            let t = dot / AB_sq;

            // Clamp t to [0, 1] to keep within segment? 
            // User requested "Vuông góc". If P is far, projection might be outside AB.
            // Let's unclamp for true perpendicular line (infinite line).
            // But visual looks better if clamped. Let's clamp.
            t = Math.max(0, Math.min(1, t));

            return {
                lat: y1 + t * A_to_B.y,
                lng: x1 + t * A_to_B.x
            };
        }

        function renderMap(nodeMap, segColors) {
            // Clear layers
            Object.values(layers).forEach(l => l.clearLayers());

            // 1. Render Nodes (Poles, MC, Sources)
            // Smart Zoom: <15 Hide poles
            let z = map.getZoom();
            let showPoles = z >= 15;

            for(let l in appData.poles) {
                appData.poles[l].forEach(p => {
                    let type = p.type;
                    let target = null;
                    let icon = null;
                    let zIdx = 0;

                    if (type === 'NGUON') {
                        target = layers.source;
                        zIdx = 2000;
                        let color = VOLTAGE_COLORS[p.voltage] || '#000';
                        icon = L.divIcon({
                            className: 'icon-source',
                            html: p.voltage, // Text inside circle
                            iconSize: [24, 24],
                            bgPos: [12, 12]
                        });
                        // Inject dynamic color style via JS usually hard, using inline style in html string
                        icon = L.divIcon({
                            className: '',
                            html: `<div class="icon-source" style="background:${color}; width:24px; height:24px;">${p.voltage}</div>`,
                            iconSize: [24, 24]
                        });

                    } else if (type === 'MC') {
                        target = layers.mc;
                        let isOn = appData.mcStates[p.name] !== false;
                        let cls = isOn ? 'icon-mc-on' : 'icon-mc-off';
                        // Get last 3 digits
                        let label = p.name.match(/\d{3}$/);
                        label = label ? label[0] : p.name.slice(-3);
                        icon = L.divIcon({ className: cls, html: label, iconSize: [20, 14] }); // Hinh chu nhat
                        
                    } else if (type === 'THANH_CAI' || type === 'DIEM_NOI') {
                         // Không vẽ icon cho điểm nối thanh cái, chỉ dùng để nối dây
                         return; 
                    } else {
                        // Trụ
                        if(showPoles) {
                            target = layers.points;
                            let cls = (type==='TRU_NEO')?'icon-tru-neo':'icon-tru-do';
                            icon = L.divIcon({ className: cls, iconSize: [10, 10] });
                        }
                    }

                    if (target && icon) {
                        let m = L.marker([p.lat, p.lng], { icon: icon, zIndexOffset: zIdx }).addTo(target);
                        if(type === 'MC') m.on('click', () => window.showMCConfirm(p.name));
                        else m.bindPopup(p.name);
                    }
                });
            }

            // 2. Render Segments (Lines & Busbars)
            if(appData.segments) {
                Object.values(appData.segments).forEach(seg => {
                    let p1 = nodeMap[seg.fromNode];
                    let p2 = nodeMap[seg.toNode];
                    if(!p1 || !p2) return;

                    let color = VOLTAGE_COLORS[segColors[seg.id]] || '#000';
                    let weight = 3;
                    let points = [ [p1.lat, p1.lng], [p2.lat, p2.lng] ];
                    
                    // XỬ LÝ THANH CÁI
                    if (seg.type === 'THANH_CAI') {
                        weight = 6; // Dày hơn
                        // Màu thanh cái cũng theo điện áp
                        L.polyline(points, {color: color, weight: weight, pane: 'busbarPane'}).addTo(layers.busbar);
                        return;
                    }

                    // XỬ LÝ VUÔNG GÓC (MC -> THANH CÁI)
                    // Kiểm tra nếu điểm đầu hoặc điểm cuối thuộc về một thanh cái
                    let busbarInfo = activeBusbars[seg.fromNode] || activeBusbars[seg.toNode];
                    
                    if (busbarInfo) {
                        // Tìm điểm nào là MC (hoặc điểm nhánh), điểm nào nằm trên thanh cái
                        let busNode = activeBusbars[seg.fromNode] ? p1 : p2;
                        let otherNode = (busNode === p1) ? p2 : p1;

                        // Tính điểm chiếu vuông góc H từ otherNode xuống đường thẳng của thanh cái (busbarInfo.p1, busbarInfo.p2)
                        let H = getProjectedPoint(otherNode, busbarInfo.p1, busbarInfo.p2);
                        
                        // Vẽ dây từ otherNode -> H
                        points = [ [otherNode.lat, otherNode.lng], [H.lat, H.lng] ];
                    }

                    // Vẽ dây thường
                    L.polyline(points, {color: color, weight: weight, pane: 'linePane'}).addTo(layers.line);
                });
            }
        }

        // --- ZOOM HANDLER ---
        map.on('zoomend', () => {
            let z = map.getZoom();
            if (z >= 15) {
                if(!map.hasLayer(layers.points)) map.addLayer(layers.points);
            } else {
                if(map.hasLayer(layers.points)) map.removeLayer(layers.points);
            }
        });

        // --- LEGEND UPDATE ---
        var legendControl = L.control({position: 'bottomright'});
        legendControl.onAdd = function (map) {
            var div = L.DomUtil.create('div', 'legend');
            div.innerHTML = `
                <h4>ĐIỆN ÁP</h4>
                <div class="legend-item"><span class="legend-icon" style="background:#2196F3"></span> 500 kV</div>
                <div class="legend-item"><span class="legend-icon" style="background:#F44336"></span> 220 kV</div>
                <div class="legend-item"><span class="legend-icon" style="background:#2E7D32"></span> 110 kV</div>
                <div class="legend-item"><span class="legend-icon" style="background:#000"></span> Mất điện</div>
            `;
            return div;
        };
        legendControl.addTo(map);

        // --- ZOOM TO TARGET (By Route/Line Name) ---
        window.zoomToTarget = function() {
            let val = document.getElementById('circuitSelect').value;
            if(!val) return;
            if(appData.poles[val]) {
                let bounds = appData.poles[val].map(p=>[p.lat,p.lng]);
                map.fitBounds(bounds);
            }
        }

    </script>
</body>
</html>

